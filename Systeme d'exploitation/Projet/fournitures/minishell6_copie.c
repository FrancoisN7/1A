#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h> /* wait */
#include <stdbool.h>
#include "readcmd.h"
#include <string.h>
#include <signal.h>


/*
Repeter
	lire la commande
	executer la commande
	tant que commande en avant plan alors
		attendre signal (pause();)  //commande_avant_plan mise a jour ds le handler child
	fin tantque
fin repeter

commande en avant plan peut être implanté par un entier qui
contient le pid de la commande en avant plan ou 0 

commande_avant_plan <- pid du fils si commande lancee en avant plan
commande_avant_plan <- pid du processus concerne par la commande fg
commande_avant_plan <- 0 si (exit ou signal ou suspension) et fils_termine == commande_avant_plan

la solution la plus simple repose sur une seul waitpid avec les bonnes options dans le
handler sigchild, et une mise a jour de la liste dans ce handler.
C l'endroit dans lequel on se trouve lorsque un fils subit un changement d'état
Et si on y regroupe tous les traitements concernant ces changements d'état,
on évite les pbs de redondance, d'incohérences, d'oubli, ou de blocage
*/



/*------------------Définition des paramètres------------------------------------------*/
#define CAPACITE 200
int nbProc = 1; 

//Définition du type Etat
typedef enum {
    Suspendu,Actif,Erreur
} T_Etat;
T_Etat Etat_t;

//Définition du type processus
typedef struct Processus {
    pid_t pidProc;
    T_Etat etatProc;
    char* commandeProc; 
    } Processus;  
typedef Processus listeProc_t[CAPACITE];

/* variable globale car modifiée par le traitant */
listeProc_t listeProc; 
struct cmdline *commande;
pid_t pidFils, commande_avant_plan;


/*-----------------Fonctions utiles à l'affichage--------------------------------------*/
//Traduit l'état d'entier 1/0 à Actif/Suspendu
char* traduireEtat(T_Etat etat){
    char* Etat = "Actif";
    if (etat == Suspendu){
        Etat = "Suspendu";
    }
    if ((etat != Suspendu) && (etat != Actif)){
        Etat = "Erreur";
    }
    return(Etat);
}

//Ajouter nbEspace espaces
void ajouterEspace(int nbEspace){
    for (int i=0;i<nbEspace;i++){
        printf(" ");
    }
}

//Trouver la taille que représente un entier quand on l'affiche
int trouverTaille(int entier){
    int taille=0;
    while (entier != 0){
        entier = entier/10;
        taille++;
    }
    return taille;
}

//Afficher la liste des processus
void afficherListeProc(listeProc_t listeProc){
    int nb_espaces = 7;
    printf("test1\n");
    char* Etat;
    printf("Numéro");
    ajouterEspace(nb_espaces);
    printf("Pid");
    ajouterEspace(nb_espaces); 
    printf("Etat");
    ajouterEspace(nb_espaces);
    printf("Commande\n");
    for (int i=1; i<nbProc; i++){
        if (listeProc[i-1].etatProc != Erreur){
             //Afficher le numéro du processus
            printf("%i",i);
            ajouterEspace(nb_espaces-1+strlen("Numéro")-trouverTaille(i));
            //Afficher le pid du processus
            printf("%i",listeProc[i-1].pidProc);
            ajouterEspace(nb_espaces+strlen("Pid")-
            trouverTaille((int)listeProc[i-1].pidProc));
            //Afficher l'Etat du processus
            Etat = traduireEtat(listeProc[i-1].etatProc);
            printf("%s",Etat);
            ajouterEspace(nb_espaces+strlen("Etat")-strlen(Etat));
            //Afficher la commande
            printf("%s\n", listeProc[i-1].commandeProc);
        }
       
    }
}




/*-----------------Sous-programmes utiles pour le main---------------------------------*/
/*----Sous-programmes pour lj----*/
//Parcourir la liste pour trouver le bon Processus
//Ici le pid correspond forcément à un élément de la liste 
int TrouverProc(listeProc_t listeProc, int pid){
    int ind=0;
    while (listeProc[ind].pidProc != pid){
        ind += 1;
    }
    return ind;
}

//Ajouter un nouveau processus à liste Proc
void ajouterProc(pid_t pidFils,char* commande1){
    //Allocation
    listeProc[nbProc-1].commandeProc = malloc(sizeof(char)*strlen(commande1));

    //Ajout du nouveau processus
    listeProc[nbProc-1].pidProc= pidFils;
    listeProc[nbProc-1].etatProc = Actif; 
    strcpy(listeProc[nbProc-1].commandeProc, commande1);
    nbProc++;
}



/*----Sous-programmes pour sj, bg, fg----*/
//Suspendre un processus en arrière-plan
void suspendre(int i){
    if (i-1<nbProc && listeProc[i-1].etatProc == Actif){
        kill(listeProc[i-1].pidProc, SIGSTOP);
        listeProc[i-1].etatProc = Suspendu;
        printf("ok");
    }
    else {
        printf("Ce processus n'existe pas ou n'est pas actif \n");
    }
}

//Reprendre un processus en arrière-plan
void reprendreArriereP(int i){
    //On vérifie que le processus est suspendu
    if (0<=i-1 && i-1<nbProc && listeProc[i-1].etatProc == Suspendu){
        kill(listeProc[i-1].pidProc, SIGCONT);
        listeProc[i-1].etatProc = Actif;
    }
    else {
        printf("Ce processus n'existe pas ou n'est pas suspendu \n");
    }
}

//Reprendre un processus en avant-plan
void reprendreAvantP(int i){
    //On vérifie que le processus est suspendu
    if (0<=i-1 && i-1<nbProc && listeProc[i-1].etatProc == Suspendu){
        commande_avant_plan = listeProc[i-1].pidProc;
        kill(listeProc[i-1].pidProc, SIGCONT);
        listeProc[i-1].etatProc = Actif;
        while (commande_avant_plan > 0){
            pause();
        }
    }
    else {
        printf("Ce processus n'existe pas ou n'est pas suspendu \n");
    }
}

/*-------------------Traitant du signal SIGCHLD----------------------------------------*/
void handler_sigchld(int signal_num) {
    int wstatus, fils_termine;
    fils_termine = waitpid(-1, &wstatus, WNOHANG | WUNTRACED | WCONTINUED);
    int indProc;

    if WIFEXITED(wstatus) {   /* fils terminé avec exit */

        //La commande en avant-plan est terminée
        if (fils_termine==commande_avant_plan){
            commande_avant_plan = 0;
        } else {
            indProc = TrouverProc(listeProc,fils_termine);
            listeProc[indProc].etatProc = Erreur;
        }

        //La commande a été exécutée correctement
		if (wstatus == 0){
            printf("SUCCES\n");
        }
		//>>> Il doit être supprimé, sinon votre tableau de 100 va exploser
    }

    else if WIFSIGNALED(wstatus) {  /* fils tué par un signal */
    }
	//>>> il faut traiter les suspension et les relances
	
    return ;
    //Pensez aux 4 types de WIF (STOPPED/CONTINUED)
}



/*------------------------Code du main-------------------------------------------------*/
int main() {
    int pidJob;
    bool sortie, sansfils, commande_cd, commande_exit, commande_lj, 
    commande_bg, commande_sj, commande_fg;
    char *direction;
    
    /* associer traitant sigchld à SIGCHLD */
    signal(SIGCHLD, handler_sigchld);

    do {
        //Affichage des chevrons et lecture de la commande
        printf(">>> ");
        /* Vidange du tampon de sortie pour que le fils le récupère vide */
        fflush(stdout);
        //Lecture de la commande
        commande = readcmd();
        
        if (commande->seq[0] != NULL){ //Condition correspondant à une entrée nulle

        //Création des conditions de sortie et de création de fils
        commande_exit = (strcmp("exit",commande->seq[0][0]) == 0);
        sortie = commande_exit;
        commande_cd = strcmp("cd",commande->seq[0][0]) == 0;
        commande_lj = strcmp("lj",commande->seq[0][0]) == 0;
        commande_sj = strcmp("sj",commande->seq[0][0]) == 0;
        commande_bg = strcmp("bg",commande->seq[0][0]) == 0;
        commande_fg = strcmp("fg",commande->seq[0][0]) == 0;
        sansfils = (commande_lj || commande_cd || commande_exit
        || commande_sj || commande_bg || commande_fg);
            
            if (sansfils) {
                if (commande->seq[0][1]!=NULL)
                {
                    pidJob = atol(commande->seq[0][1]);
                }
                else{
                    pidJob = -1;
                }

                //Execution de cd   
                if (commande_cd) {
                    if ((strcmp(commande->seq[0][1], "~")) == 0){
                        direction = getenv("HOME");
                    }
                    else {
                        direction = commande->seq[0][1];
                    }
                    chdir(direction);
                    execlp("cd","cd", commande->in, NULL);
                    continue;      //affiche le prompt du mini-shell
                }

				//>>> il faut un else ici
                //Execution de lj  
                if (commande_lj) {
                    printf("cc");
                    afficherListeProc(listeProc);
                    continue;     //affiche le prompt du mini-shell
                }
				//>>> il faut un else ici
                //Execution de sj  
                if (commande_sj) {
                    suspendre(pidJob);
                    printf("t\n");
                    continue;     //affiche le prompt du mini-shell
                }

				//>>> il faut un else ici
                //Execution de bg  
                if (commande_bg) {
                    reprendreArriereP(pidJob);
                    continue;     //affiche le prompt du mini-shell
                }

				//>>> il faut un else ici
                //Execution de fg
                if (commande_fg) {
                    reprendreAvantP(pidJob);
                    continue;     //affiche le prompt du mini-shell
                }
            }
            
            //Execution des commandes avec des fils
            else {
                pidFils = fork();
                /* bonne pratique : tester systématiquement le retour des appels système */
                if (pidFils == -1) {
                    NULL;
                }
                
                // Création du fils   
                if (pidFils == 0) {
                    execvp(commande->seq[0][0], commande->seq[0]);
                    printf ("ECHEC \n");
                    exit(2);
                }

                // Création du père
                else {
                    //Option "&" qui signifie une commande en arrière plan
                    //Soit on traite la commande en avant-plan
                    if (commande->backgrounded == NULL) {
                    commande_avant_plan = pidFils;
                        while (commande_avant_plan > 0){
                            pause();
                        }
                    }
                    //Soit on traite la commande en arrière-plan
                    else{
                        ajouterProc(pidFils,commande->seq[0][0]);
                    }
                }
            }
        } 
        
    } while (!sortie);
        
    //Affichage Salut à la sortie de la boucle 
    printf("Salut \n");
     
    return EXIT_SUCCESS; /* -> exit(EXIT_SUCCESS); pour le père */
}
