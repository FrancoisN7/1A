#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h> /* wait */
#include <stdbool.h>
#include "readcmd.h"
#include <string.h>
#include <signal.h>

//>>> pbs de conception et incohérences
//>>> voir commentaires dans le code

//>>> je vous rappelle l'algo présenté hier au tableau
//>>> boucle du shell
/*
Repeter
	lire la commande
	executer la commande
	tant que commande en avant plan alors
		attendre signal (pause();)  //ccommande_avant_plan mise a jour ds le handler child
	fin tantque
fin repeter

commande en avant plan peut être implanté par un entier qui
contient le pid de la commande en avant plan ou 0 

commande_avant_plan <- pid du fils si commande lanceee en avnat plan
commande_avant_plan <- pid du processus concerne par la commande fg
commande_avant_plan <- 0 si (exit ou signal ou suspension) et fils_termine == commande_avant_plan

la solution la plus simple repose sur une seul waitpid avec les bonnes options dans le
handler sigchild, et une mise a jour de la liste dans ce handler.
C l'endroit dans lequel on se trouve lorsque un fils subit un changement d'état
Et si on y regroupe tous les traitements concernant ces changements d'état,
on évite les pbs de redondance, d'incohérences, d'oubli, ou de blocage
*/



/*------------------Définition des paramètres------------------------------------------*/
#define CAPACITE 100
int nbProc = 1; 
typedef struct Processus {
    pid_t pidProc;
    int etatProc;
    char* commandeProc; 
    } Processus;  
typedef Processus listeProc_t[CAPACITE];
listeProc_t listeProc; /* variable globale car modifiée par le traitant */


/*-----------------Fonctions utiles à l'affichage--------------------------------------*/
//Traduit l'état d'entier 1/0 à Actif/Suspendu
char* traduireEtat(int i){
    char* Etat = "Actif";
    if (i == 0){
	//>>> Utiliser une énumération
	//>>> on aura du mal à se rappeler ce représente 0, 1 ou -1
        Etat = "Suspendu";
    }
    if ((i!=0) && (i!=1)){
        Etat = "Erreur";
    }
    return(Etat);
}

//Ajouter nbEspace espaces
void ajouterEspace(int nbEspace){
    for (int i=0;i<nbEspace;i++){
        printf(" ");
    }
}

//Trouver la taille que représente un entier quand on l'affiche
int trouverTaille(int entier){
    int taille=0;
    while (entier != 0){
        entier = entier/10;
        taille++;
    }
    return taille;
}

//Afficher la liste des processus
void afficherListeProc(listeProc_t listeProc){
    int nb_espaces = 7;
    printf("test1\n");
    char* Etat;
    printf("Numéro");
    ajouterEspace(nb_espaces);
    printf("Pid");
    ajouterEspace(nb_espaces); 
    printf("Etat");
    ajouterEspace(nb_espaces);
    printf("Commande\n");
    for (int i=1; i<nbProc; i++){
        //if (listeProc[i-1].etatProc != -1){
             //Afficher le numéro du processus
            printf("%i",i);
            ajouterEspace(nb_espaces-1+strlen("Numéro")-trouverTaille(i));
            //Afficher le pid du processus
            printf("%i",listeProc[i-1].pidProc);
            ajouterEspace(nb_espaces+strlen("Pid")-
            trouverTaille((int)listeProc[i-1].pidProc));
            //Afficher l'Etat du processus
            Etat = traduireEtat(listeProc[i-1].etatProc);
            printf("%s",Etat);
            ajouterEspace(nb_espaces+strlen("Etat")-strlen(Etat));
            //Afficher la commande
            printf("%s\n", listeProc[i-1].commandeProc);
        //}
       
    }
}




/*-----------------Sous-programmes utiles pour le main---------------------------------*/
/*----Sous-programmes pour lj----*/
//Parcourir la liste pour trouver le bon Processus
//Ici le pid correspond forcément à un élément e la liste 
int TrouverProc(listeProc_t listeProc, int pid){
    int ind=0;
    while (listeProc[ind].pidProc != pid){
        ind += 1;
    }
    return ind;
}

//Ajouter un nouveau processus à liste Proc
void ajouterProc(listeProc_t listeProc,pid_t pidFils,char* commande1){
    //Allocation
    listeProc[nbProc-1].commandeProc = malloc(sizeof(char)*strlen(commande1));

    //Ajout du nouveau processus
    listeProc[nbProc-1].pidProc= pidFils;
    listeProc[nbProc-1].etatProc = 1;
    strcpy(listeProc[nbProc-1].commandeProc, commande1);
    nbProc++;
}



/*----Sous-programmes pour sj, bg, fg----*/
//Suspendre un processus en arrière-plan
void suspendre(int i){
	
    if (i-1<nbProc && listeProc[i-1].etatProc == 1){
        kill(listeProc[i-1].pidProc, SIGTSTP);
		//>>> OK vous envoyez SIGCONT, mais vous ne le traitez jamais
		//>>> ds le handler
        listeProc[i-1].etatProc = 0;
        printf("ok");
    }
    else {
        printf("Ce processus n'existe pas ou n'est pas actif \n");
    }
}

//Reprendre un processus en arrière-plan
void reprendreArriereP(int i){
    //On vérifie que le processus est suspendu
    if (i-1<nbProc && listeProc[i-1].etatProc == 0){
        kill(listeProc[i-1].pidProc, SIGCONT);
		//>>> OK vous envoyez SIGCONT, mais vous ne le traitez jamais
		//>>> ds le handler
        listeProc[i-1].etatProc = 1;
    }
    else {
        printf("Ce processus n'existe pas ou n'est pas suspendu \n");
    }
}

//Reprendre un processus en arrière-plan
void reprendreAvantP(int i){
    int status2;
    //On vérifie que le processus est suspendu
    if (i-1<nbProc && listeProc[i-1].etatProc == 0){
        kill(listeProc[i-1].pidProc, SIGCONT);
		//>>> OK vous envoyez SIGCONT, mais vous ne le traitez jamais
		//>>> ds le handler
        listeProc[i-1].etatProc = 1;
        //wait(&status2);
		
		//>>> comment pensez vous bloquer le terminal
    }
    else {
        printf("Ce processus n'existe pas ou n'est pas suspendu \n");
    }
}

/*-------------------Traitant du signal SIGCHLD----------------------------------------*/
void handler_sigchld(int signal_num) {
    int wstatus, fils_termine;
	
	//>>> voir l'exemple ds le tutoriel avec le waitpid qui
	//>>> traite les cas : exit; tué par signal, suspendu, relancé
	
    fils_termine = wait(&wstatus);
    int indProc = TrouverProc(listeProc,fils_termine);
    if WIFEXITED(wstatus) {   /* fils terminé avec exit */
        //printf("\nMon fils de pid %d a termine avec exit %d\n", 
        //fils_termine, WEXITSTATUS(wstatus);
        listeProc[indProc].etatProc = -1;
		
		//>>> Il doit être supprimé, sinon votre tableau de 100 va exploser
		
    }
    else if WIFSIGNALED(wstatus) {  /* fils tué par un signal */
        //printf("\nMon fils de pid %d a ete tue par le signal %d\n", 
                //fils_termine, WTERMSIG(wstatus)) ;
        listeProc[indProc].etatProc = 0;
		//>>> Il doit être supprimé, sinon votre tableau de 100 va exploser
    }
	
	//>>> il faut traiter les suspension et les relances
	
    return ;
}



/*------------------------Code du main-------------------------------------------------*/
int main() {
    struct cmdline *commande;
    pid_t pidFils, idFils;
    int codeTerm, pidJob;
    bool sortie, sansfils, commande_cd, commande_exit, commande_lj, 
    commande_bg, commande_sj, commande_fg;
    char *direction;
    signal(SIGCHLD, handler_sigchld);
    signal(SIGCONT, handler_sigcont);*
    signal(
    do {
        //Affichage des chevrons et lecture de la commande
        printf(">>> ");
        /* Vidange du tampon de sortie pour que le fils le récupère vide */
        fflush(stdout);
        commande = readcmd();
        
        if (commande->seq[0] != NULL){ //Condition correspondant à une entrée nulle

        //Création des conditions de sortie et de création de fils
        commande_exit = (strcmp("exit",commande->seq[0][0]) == 0);
        sortie = commande_exit;
        commande_cd = strcmp("cd",commande->seq[0][0]) == 0;
        commande_lj = strcmp("lj",commande->seq[0][0]) == 0;
        commande_sj = strcmp("sj",commande->seq[0][0]) == 0;
        commande_bg = strcmp("bg",commande->seq[0][0]) == 0;
        commande_fg = strcmp("fg",commande->seq[0][0]) == 0;
        sansfils = (commande_lj || commande_cd || commande_exit
        || commande_sj || commande_bg || commande_fg);
            
            if (sansfils) {
                if (commande->seq[0][1]!=NULL)
                {
                    pidJob = atol(commande->seq[0][1]);
                }
                else{
                    pidJob = 1500; //>>> bizarre comme approche
                }

                //Execution de cd   
                if (commande_cd) {
                    if ((strcmp(commande->seq[0][1], "~")) == 0){
                        direction = getenv("HOME");
                    }
                    else {
                        direction = commande->seq[0][1];
                    }
                    chdir(direction);
                    execlp("cd","cd", commande->in, NULL);
                    continue;      //affiche le prompt du mini-shell
                }

				//>>> il faut un else ici
                //Execution de lj  
                if (commande_lj) {
                    printf("cc");
                    afficherListeProc(listeProc);
                    continue;     //affiche le prompt du mini-shell
                }
				//>>> il faut un else ici
                //Execution de sj  
                if (commande_sj) {
                    suspendre(pidJob);
                    printf("t\n");
                    //continue;     //affiche le prompt du mini-shell
                }

				//>>> il faut un else ici
                //Execution de bg  
                if (commande_bg) {
                    reprendreArriereP(pidJob);
                    continue;     //affiche le prompt du mini-shell
                }

				//>>> il faut un else ici
                //Execution de fg
                if (commande_fg) {
                    reprendreAvantP(pidJob);
                    continue;     //affiche le prompt du mini-shell
                }
            }
            
            //Execution des commandes avec des fils
            else {
                pidFils = fork();
            
                /* bonne pratique : tester systématiquement le retour des appels système */
                if (pidFils == -1) {
                    NULL;
                }
                
                // Création du fils   
                if (pidFils == 0) {
                    execvp(commande->seq[0][0], commande->seq[0]);
                    printf ("ECHEC \n");
                    exit(2);
                }

                // Création du père
                else {
                //Option "&" qui empêche le wait
                    if (commande->backgrounded == NULL) {
						
						//>>> au mieux redondance avec handlet child
						//>>> au pire, conflit ou blocage
						//>>> pensez  la solution présentée hier
                        idFils = waitpid(pidFils,&codeTerm,0);
                        
                        if ( idFils == -1) {
                            perror ("wait");
                            exit (8);
                        }
                        //Affichage de succès si la commande execvp a fonctionné
                        if (WEXITSTATUS(codeTerm) != 2) {
                            printf ("SUCCES \n");
							
							//>>> ou mettez-vous  jour la liste ?
							//>>> et que faire de la suspension ?
                        }
                    }
                    else {
                        if (!sortie && WEXITSTATUS(codeTerm) != 2) {
							
						//>>> d'ou vient WEXITSTATUS(codeTerm) ???
						//>>> avez fait un wait ?
						//>>> doit-on attendre l fin pour ajouter ds liste
                        ajouterProc(listeProc,pidFils,commande->seq[0][0]);
                        }
                    }

                }
            }
        } 
        
    } while (!sortie);
        
    //Affichage Salut à la sortie de la boucle 
    printf("Salut \n");
     
    return EXIT_SUCCESS; /* -> exit(EXIT_SUCCESS); pour le père */
}
